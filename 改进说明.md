# 项目改进说明

## 一、跳句功能改进

### 1.1 当前问题分析

根据日志文件 `logs/skip_20251130_190654.log` 的分析：

1. **完全重复检测**：`'你则是个如花' == '你则是个如花'`
   - 当前实现：简单的字符串相等比较 ✓ 已实现

2. **部分重复检测**：`'诶哒' 是 '哒诶哒' 的一部分`
   - 当前实现：使用 `in` 操作符检查包含关系
   - **问题**：这种方法可能误判，例如 "你好" 和 "你好世界" 会被正确识别，但 "你好" 和 "你很好" 可能不会被识别为相似

### 1.2 改进方案

#### 新增模块：`improved_skip_detector.py`

**核心改进**：

1. **编辑距离算法**（Levenshtein Distance）
   - 计算两个文本的编辑距离，转换为相似度（0-1）
   - 更准确地识别相似文本，而不仅仅是包含关系
   - 例如："你好" 和 "你很好" 的相似度约为 0.67（如果阈值设为 0.85，则不会跳过）

2. **时间窗口机制**
   - 只在指定时间窗口内（默认 3 秒）进行去重
   - 避免长时间后仍然跳过相似文本
   - 例如：3 秒前说过 "你好"，现在又说 "你好" 会被跳过；但 5 秒后再说 "你好" 则不会被跳过

3. **相似度阈值**
   - 可配置的相似度阈值（默认 0.85）
   - 支持两种算法：
     - `SequenceMatcher`：基于最长公共子序列（快速）
     - `编辑距离`：基于字符编辑操作（更准确）

4. **历史记录管理**
   - 维护时间窗口内的历史记录
   - 自动清理超出时间窗口的记录
   - 支持检查历史记录中的相似文本

**使用示例**：

```python
from improved_skip_detector import ImprovedSkipDetector

# 创建检测器
detector = ImprovedSkipDetector(
    similarity_threshold=0.85,  # 相似度阈值
    time_window=3.0,  # 3秒时间窗口
    min_length=2,  # 最小文本长度
    use_edit_distance=True  # 使用编辑距离算法
)

# 检查是否应该跳过
should_skip, reason, details = detector.should_skip("你好世界", time.time())
if should_skip:
    print(f"跳过原因: {reason}, 详情: {details}")
```

**统计信息**：

```python
stats = detector.get_stats()
# 返回：
# {
#     'total_checked': 100,  # 总检查次数
#     'skipped_duplicate': 10,  # 完全重复次数
#     'skipped_partial': 5,  # 部分重复次数
#     'skipped_similar': 3,  # 相似文本次数
#     'passed': 82,  # 通过次数
#     'total_skipped': 18,  # 总跳过次数
#     'skip_rate': 18.0,  # 跳过率（%）
#     'history_size': 5  # 当前历史记录数
# }
```

### 1.3 配置建议

根据实际使用情况，可以调整以下参数：

- **相似度阈值** (`similarity_threshold`)：
  - `0.9-0.95`：严格模式，只跳过非常相似的文本
  - `0.85`：平衡模式（推荐）
  - `0.7-0.8`：宽松模式，跳过更多相似文本

- **时间窗口** (`time_window`)：
  - `1.0-2.0`：短窗口，适合快速对话
  - `3.0-5.0`：中等窗口（推荐）
  - `5.0+`：长窗口，适合慢速对话

- **最小文本长度** (`min_length`)：
  - `1`：包括单字符
  - `2-3`：推荐，避免误判短文本
  - `4+`：只检查较长文本

## 二、音频设备保护

### 2.1 当前问题

- 音频设备被其他程序占用时，程序直接退出
- 没有重试机制
- 设备断开后无法自动恢复
- 错误信息不够详细

### 2.2 改进方案

#### 新增模块：`audio_device_protector.py`

**核心功能**：

1. **设备可用性检测**
   - 在打开流之前检查设备是否可用
   - 检测设备是否被占用
   - 提供详细的错误信息

2. **自动重试机制**
   - 设备被占用时自动重试（默认 3 次）
   - 可配置重试延迟（默认 1 秒）
   - 智能等待设备释放

3. **流健康检查**
   - 定期检查流的健康状态
   - 检测流是否仍然激活
   - 及时发现设备断开

4. **自动恢复机制**
   - 检测到设备错误时自动尝试恢复
   - 关闭旧流并重新打开
   - 记录恢复次数和状态

5. **错误处理增强**
   - 区分不同类型的错误（设备无效、设备占用、设备断开等）
   - 提供详细的错误信息和建议
   - 优雅降级（如果保护模块不可用，回退到基础模式）

**使用示例**：

```python
from audio_device_protector import AudioDeviceProtector

# 创建设备保护器
protector = AudioDeviceProtector(
    max_retries=3,  # 最大重试次数
    retry_delay=1.0,  # 重试延迟（秒）
    check_interval=0.5  # 检查间隔（秒）
)

# 打开流（带自动重试）
success, stream, error = protector.open_stream(
    device_index=0,
    samplerate=16000,
    channels=1,
    blocksize=512,
    dtype='float32'
)

if success:
    # 读取音频（带错误处理）
    audio_data, overflowed, read_error = protector.read_audio(512)
    if audio_data is None:
        if "设备已恢复" in read_error:
            # 设备已恢复，继续使用
            pass
        else:
            # 尝试恢复
            success, new_stream, recover_error = protector.recover_stream(...)
else:
    print(f"打开失败: {error}")

# 获取状态
status = protector.get_status()
# 返回：
# {
#     'device_index': 0,
#     'device_name': '麦克风名称',
#     'is_streaming': True,
#     'is_healthy': True,
#     'health_error': None,
#     'last_error': None,
#     'recovery_count': 0
# }
```

### 2.3 错误处理流程

```
打开设备
  ↓
检查设备可用性
  ↓ (失败)
返回错误信息
  ↓ (成功)
尝试打开流
  ↓ (失败 - 设备被占用)
等待并重试（最多3次）
  ↓ (失败)
返回错误信息
  ↓ (成功)
验证流正常工作
  ↓ (失败)
关闭流并重试
  ↓ (成功)
返回流对象
```

**读取音频时的错误处理**：

```
读取音频
  ↓ (失败 - 设备断开)
尝试恢复流
  ↓ (成功)
继续使用
  ↓ (失败)
返回错误信息
```

## 三、其他改进建议

### 3.1 配置管理

建议添加配置文件（如 `config.json` 或 `config.yaml`），集中管理所有配置：

```json
{
  "skip_detector": {
    "similarity_threshold": 0.85,
    "time_window": 3.0,
    "min_length": 2,
    "use_edit_distance": true
  },
  "device_protector": {
    "max_retries": 3,
    "retry_delay": 1.0,
    "check_interval": 0.5
  },
  "audio": {
    "sampling_rate": 16000,
    "channels": 1,
    "blocksize": 512
  }
}
```

### 3.2 性能监控

- 添加跳句统计信息的实时显示
- 监控设备恢复次数和成功率
- 记录设备错误频率和类型

### 3.3 用户体验

- 在控制台显示设备保护状态（如 "设备保护已启用"）
- 显示跳句统计信息（可选）
- 提供更友好的错误提示

### 3.4 日志增强

- 记录设备恢复事件
- 记录跳句检测的详细信息（相似度、时间差等）
- 添加性能指标日志

### 3.5 测试建议

1. **跳句功能测试**：
   - 测试完全重复文本
   - 测试部分重复文本
   - 测试相似文本（不同相似度阈值）
   - 测试时间窗口机制

2. **设备保护测试**：
   - 测试设备被占用时的重试机制
   - 测试设备断开后的自动恢复
   - 测试多个程序同时使用设备的情况

## 四、使用说明

### 4.1 启用新功能

新功能已自动集成到主程序中，无需额外配置。如果模块文件存在，会自动启用：

- `audio_device_protector.py` 存在 → 启用设备保护
- `improved_skip_detector.py` 存在 → 启用改进的跳句检测

如果模块不存在，程序会自动回退到基础模式。

### 4.2 自定义配置

如果需要自定义配置，可以在主程序中修改：

```python
# 在 record_session 函数中
skip_detector = ImprovedSkipDetector(
    similarity_threshold=0.9,  # 更严格的相似度阈值
    time_window=5.0,  # 更长的时间窗口
    min_length=3,  # 最小文本长度
    use_edit_distance=True
)

# 设备保护器
device_protector = AudioDeviceProtector(
    max_retries=5,  # 更多重试次数
    retry_delay=2.0,  # 更长的重试延迟
    check_interval=1.0  # 更长的检查间隔
)
```

## 五、总结

### 5.1 跳句功能改进

✅ **已完成**：
- 使用编辑距离算法提高相似度检测准确性
- 添加时间窗口机制，避免长时间去重
- 支持历史记录检查
- 提供详细的统计信息

### 5.2 音频设备保护

✅ **已完成**：
- 设备可用性检测
- 自动重试机制
- 流健康检查
- 自动恢复机制
- 详细的错误处理

### 5.3 后续建议

- 添加配置文件支持
- 增强性能监控
- 改进用户体验
- 添加单元测试

